// viterby.cpp: определяет точку входа для консольного приложения.
//

#include "metrics.h"
#include "sim.h"


#include <time.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

#include "viterby27.h"


#define MAX_LE_SYMBOLS 64
// raw unwhitened bytes of packet, including access address
uint8_t decdata[MAX_LE_SYMBOLS];

int main()
{
	double ebn0, esn0, noise;

	int mettab[2][256];

	int ampitude, ndemaped, nbits, nbytes;
	
	unsigned long metricend;
	time_t seed;


	ampitude = 100;
	ebn0 = 5.0;
	time(&seed);

	esn0 = ebn0 - 10 * log10((double)Rate);	/* Es/N0 in dB */

	/* Compute noise voltage. The 0.5 factor accounts for BPSK seeing
	* only half the noise power, and the sqrt() converts power to
	* voltage.
	*/
	noise = sqrt(0.5 / pow(10., esn0 / 10.));

	gen_met(mettab, ampitude, noise, 0., 4);
	printf("metric table range %d to %d\n", mettab[0][0], mettab[1][0]);

	// Example from page 2854 (without preamble) S = 2

	uint8_t symbols[] = /* Access Adress*/
	  { 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0,
		0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1,
		0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1, 1,1,0,0,
		0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0,
		1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1,
		1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0,
		/* CI */
		0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0,

		/* TERM 1 - не несет никой информации, необходим для того, чтобы "сбросить" значение регистра в 000 */
		0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1,

		/* PDU */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1,
		1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
		1, 0,

		/* CRC */
		0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1,
		0, 1, 0, 0, 0, 0, 0, 0, 1,

		/* TERM 2 - не несет никой информации, необходим для того, чтобы "сбросить" значение регистра в 000 */
		0, 1, 0, 0, 1, 1 };


	// Example from page 2854 (without preamble) S = 8

	//uint8_t symbols[] = /* Access Adress*/
	//{ 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0,
	//	0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1,
	//	0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1, 1,1,0,0,
	//	0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0,
	//	1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1,
	//	1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0,
	//	/* CI */
	//	1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0,
	//	/* TERM 1*/
	//	1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1,

	//	/* PDU */
	//	0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1,
	//	0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1,
	//	1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0,
	//	1,1,0,0, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1,
	//	1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1,
	//	0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0,
	//	1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1,

	//	/* CRC */
	//	0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1,
	//	0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1,
	//	0,0,1,1, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0,
	//	0,0,1,1, 1,1,0,0, 1,1,0,0, 0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 0,0,1,1, 1,1,0,0,

	//	/* TERM 2*/
	//	0,0,1,1, 1,1,0,0, 0,0,1,1, 0,0,1,1, 1,1,0,0, 1,1,0,0 };

	// Количество символов в передаваемом сообщении
	int nsymbols = sizeof(symbols) / sizeof(uint8_t);

	// Добавление белого шума, при этом: [0,1] -> [0, 255]
	modnoise(&symbols[0], nsymbols, ampitude, noise);



	

	// При использовании схемы кодирования LE Coded S8 одному символу с выхода сверточного кодера соответствует 4 символа
	if (nsymbols > lenBlock1)
	{
		// FEC block 1 coded using S=8

		uint8_t *demapedFecBlock1 = new uint8_t[74]; // lenBlock1/4 = 74

		// Demapping
		patternDemapper(demapedFecBlock1, &symbols[0], lenBlock1);

		// Декодер Витерби (с инверсией порядка бит)
		viterbi(&metricend, &decdata[0], demapedFecBlock1, 37, mettab); //  74/2 = 37


		if ((decdata[4] & 0x03) == 0x01) // Coding Indicator == 10
		{
			//FEC block 2 coded using S=2
			viterbi(&metricend, &decdata[4], &symbols[lenBlock1], (nsymbols - lenBlock1)/2, mettab);
		}
		else
		{
			//FEC block 2 coded using S=8
			int ndemapedFecBlock2 = floor((nsymbols - lenBlock1) / 4);
			uint8_t *demapedFecBlock2 = new uint8_t[ndemapedFecBlock2];

			// Demapping
			patternDemapper(demapedFecBlock2, &symbols[lenBlock1], ndemapedFecBlock2*4);

			viterbi(&metricend, &decdata[4], demapedFecBlock2, ndemapedFecBlock2 / 2, mettab);

			delete[] demapedFecBlock2;

		}

		delete[] demapedFecBlock1;
	}
	




	_getch();



	
    return 0;
}

